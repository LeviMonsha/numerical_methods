import numpy as np
from numpy import linalg as LA

# два класса решения СЛАУ:
    # прямые и итерационные
    # Прямые методы основаны на предварительной
    # факторизации матрицы системы и последующем решении двух систем с
    # треугольными матрицами.

def forward_way():
    M = np.array([[3, 2, -5],
                  [2, -1, 3],
                  [1, 2, -1]])  # Матрица (левая часть системы)
    V = np.array([-1, 13, 9])  # Вектор (правая часть системы)


    #  РЕШЕНИЕ СИСТЕМЫ ЛИНЕЙНЫХ АЛГЕБРОИЧЕСКИХ
    # УРАВНЕНИЙ МАТРИЧНЫМ МЕТОДОМ
    # для решения системы линейных уравнений матричным методом
    print("МАТРИЧНЫЙ МЕТОД")
    print(np.linalg.solve(M, V))
    print("~~~")

    # РЕШЕНИЕ СИСТЕМЫ ЛИНЕЙНЫХ АЛГЕБРОИЧЕСКИХ
    # УРАВНЕНИЙ С ПОМОЩЬЮ ОПРЕДЕЛИТЕЛЕЙ
    # Применяется при нахождении уравнений регрессий
    print("МЕТОД С ПОМОЩЬЮ ОПРЕДЕЛИТЕЛЕЙ")
    O_matrix = np.linalg.det(M)  # Поиск главного определителя матрицы
    # Для нахождения определителей Δ1, Δ2, Δ3 необходимо:
    # - в матрице М заменить соответствующие столбцы на столбец - вектор.
    M1 = np.array([[-1, 2, -5], [13, -1, 3], [9, 2, -1]])
    M2 = np.array([[3, -1, -5], [2, 13, 3], [1, 9, -1]])
    M3 = np.array([[3, 2, -1], [2, -1, 13], [1, 2, 9]])
    # - найти определители Δ1, Δ2, Δ3:
    s1 = np.linalg.det(M1)
    s2 = np.linalg.det(M2)
    s3 = np.linalg.det(M3)
    # Вычисление значений x, y, z, по формулам:
    x = s1 / O_matrix
    y = s2 / O_matrix
    z = s3 / O_matrix
    print(f"x = {round(x)}\ny = {round(y)}\nz = {round(z)}")
    print("~~~")
    # Недостатком метода
    # является его практическая непригодность для вычисления СЛАУ с большим
    # количеством переменных (от 5 и выше)

def iteration_way():
    """
        Метод итерации — это численный и приближенный метод решения СЛАУ.
        Суть метода: нахождение по приближённому значению величины
        следующего приближения, которое является более точным.
        Метод позволяет получить значения корней системы с заданной
        точностью в виде предела последовательности некоторых векторов
        (итерационный процесс). Характер сходимости и сам факт сходимости метода
        зависит от выбора начального приближения корня x0.
        """

    # Для случая с больим количеством переменных
    # используют приближенные методы
    # (например, метод простой итерации)

    # ИТЕРАЦИОННЫЕ МЕТОДЫ РЕШЕНИЯ
    print("МЕТОД ПРОСТОЙ ИТЕРАЦИИ")
    a = np.array([[20.9, 1.2, 2.1, 0.9], [1.2, 21.2, 1.5, 2.5], [2.1, 1.5, 19.8, 1.3],
                  [0.9, 2.5, 1.3, 32.1]])  # Матрица (левая часть системы)
    V = np.array([[21.7], [27.46], [28.76], [49.72]])  # Вектор (правая часть системы)
    # Вычислим собственные значения матрицы:
    wa, va = LA.eigh(a)
    # Вычислим итерационный параметр:
    t = 2 / (wa.min() + wa.max())
    # Запишем начальные условия вычисления матрицы
    r = 1
    y = np.array([[1.04], [1.30], [1.45], [1.55]])  # Начальное приближение
    eps = 0.00001
    # Выполнение метода простой итерации:
    while r > 100 * eps:
        x = y - t * (a.dot(y) - V)
        r = np.linalg.norm(x - y)
        y = x
    print(x)
    # Примечание: функция norm, используемая в программе, позволяет
    # находить норму матрицы или вектора

if __name__ == '__main__':
    forward_way()
    iteration_way()

