import numpy as np
import math

import matplotlib.pyplot as plt
from scipy.optimize import fsolve

# РЕШЕНИЕ НЕЛИНЕЙНЫХ УРАВНЕНИЙ
def y(x): #создании функции
    return np.sin(x)-x**2*np.cos(x)

def func_fsolve():
    # ТЕХНОЛОГИЯ ОПРЕДЕЛЕНИЯ ВЕЩЕСТВЕННЫХ КОРНЕЙ
    # УРАВНЕНИЯ С ПОМОЩЬЮ ФУНКЦИИ fsolve()

    """
    При решении нелинейных уравнений можно использовать функцию
    fsolve() библиотеки optimize.scipy. Функция fsolve осуществляет нахождение
    корней произвольных уравнений по заданному приближению.
    Формат функции:
    fsolve (имя функции, начальное приближение)
    Перед нахождением корней необходимо построить график функции для
    определения отрезка с корнем уравнения.
    """
    x = np.linspace(-5, 5, 100)  # определение отрезка построения графика
    y = [math.sin(n * math.pi / 180.0) - n ** 2 * math.cos(n * math.pi / 180.0) for n in x]
    # запись функции
    fig, ax = plt.subplots()  # определение места графика на рисунке
    ax.plot(x, y, color="blue", label="y(x)")  # определение цвета графика и надписи
    ax.set_xlabel("x")  # подпись у горизонтальной оси х
    ax.set_ylabel("y")  # подпись у вертикальной оси y
    ax.legend()  # отображение легенды
    plt.grid(True)  # отображение сетки на графике
    plt.show()  # показать рисунок

def init_gr1():
    t = fsolve(y, (-1, 1))  # вызов функции для определения решения
    print(t)  # вывод результата

# ВЫЧИСЛЕНИЕ КОРНЕЙ ПОЛИНОМА
def func_polynom():
    """
    Нахождение сразу всех корней полинома осуществляется при помощи
    функции roots(р), в качестве аргумента которой указывается вектор с
    коэффициентами полинома. Функция roots возвращает вектор корней полинома:
    Полином в PYTHON задается вектором его коэффициентов. Например,
    задание полинома 𝑥4 − 11x3 + 9x2 + 11x − 10имеет следующий вид:
    """
    p = np.array([1, -11, 9, 11, -10])
    t = np.roots(p)
    print(t)

    """
    Число элементов вектора, т.е. число коэффициентов полинома, всегда на
    единицу больше его степени. Чтобы уйти от комплексных чисел при выводе
    можно воспользоваться функцией z.real (извлечение числа с плавающей точкой)
    """
    print(t.real)

    """
    Передавая список корней полинома, с помощью функции poly(р) можно
    получить коэффициенты уравнения
    """
    p = np.array([10, -1, 1, 1])
    t = np.poly(p)
    print(t)

# РЕШЕНИЕ НЕЛИНЕЙНОГО УРАВНЕНИЯ МЕТОДОМ БИСЕКЦИИ
def f(x):
    return x*x*x - np.cos(x) + 1

def init_gr2():
    eps = 0.00001
    a = -0.5
    b = 0.5

    while abs(a - b) > eps:
        c = (a + b)  / 2
        if (f(c) * f(a)) < 0:
            b = c
        else:
            a = c
    print(round(c, 2))

def func_bisection():
    """
    Суть метода: существует отрезок поиска решения [a;b], сначала находят
    значение функции в точке середины c, где c = (a+b)/2. Затем сравнивают знаки
    f(a) и f(c). Если знаки разные — то решение находится на отрезке [a;c], если нет
    — то решение находится на отрезке [c;b]. Таким образом сокращается область в
    2 раза. Такое сокращение происходит и дальше, пока не будет достигнута
    заданная точность.
    """
    # Перед нахождением корня уравнения необходимо построить график функции
    # для определения отрезка с корнем уравнения
    x = np.linspace(-1, 1, 100)
    y = [n*n*n - math.cos(n*math.pi / 100.0) + 1 for n in x]
    fig, ax = plt.subplots()
    ax.plot(x, y, color="blue", label="y(x)")
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.legend()
    plt.grid(True)
    plt.show()

if __name__ == '__main__':
    # f(a)*f(a+s)
    # f`(a)=(f(a+s)-f(a))/s

    # func_fsolve()
    # init_gr()

    # func_polynom()

    func_bisection()

    init_gr2()